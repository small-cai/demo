<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最小电路板长度排列问题</title>
      <link href="2021/04/20/zui-xiao-dian-lu-ban-chang-du-pai-lie-wen-ti/"/>
      <url>2021/04/20/zui-xiao-dian-lu-ban-chang-du-pai-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>本次实验，我选择课本P156页5-2作为实验报告。</p><p>(1) 首先是问题描述：</p><p>最小长度电路板排列问题是大规模电子系统设计中提出的实际问题。该问题的提法是，将n块电路板以最佳排列方案插入带有n个插槽的机箱中。n块电路板的不同的排列方式对应于不同的电路板插入方案。</p><p>设B={1，2，…，n }是n块电路板的集合。集合L={ N1，N2，…，Nm }是n块电路 板的m个连接块。其中每个连接块Ni是B的一个子集，且Ni中的电路板用同一根导线连 接在一起。</p><p>例如，设n=8，m=5。给定n块电路板及其m个连接块如下：</p><p>B={1，2，3，4，5，6，7，8}；L={ N1，N2，N3，N4，N5}；</p><p>N1={4，5，6}； N2={2，3}； N3 ={1，3}； N4={3，6}； N5 ={7，8}。</p><p>这8块电路板的一个可能的排列如图所示。</p><p><img src="https://img-blog.csdnimg.cn/20210420173938424.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210420173958255.png" alt="在这里插入图片描述"></p><p>则该电路板排列的密度分别是2，3。</p><p> 左上图中，跨越插槽2和3,4和5，以及插槽5和6的连线数均为2。插槽6和7之间无跨越连线。其余插槽之间只有1条跨越连线。在设计机箱时，插槽一侧的布线间隙由电路板的排列的密度确定。因此，电路板排列问题要求对于给定的电路板连接条件(连接块)，确定电路板的最佳排列，使其具有最小密度。</p><p>(2) 问题分析</p><p>电路板排列问题是NP难问题，因此不大可能找到解此问题的多项式时间算法。考虑采用回溯法系统的搜索问题解空间的排列树，找出电路板的最佳排列。排列树问题。对所有的电路板进行全排列，每次找到连接块的最左和最右电路板，相减得到连接块的长度，在全排列的过程中找到最小长度。</p><p>(3) 代码描述</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//最小电路板排列问题#include&lt;iostream&gt;using namespace std;const int maxn = 10000;int originalxu[maxn];//保留初始排序int finalxu[maxn];//保留处理后的排序int n;//讲变量n分配到全局，方便后续的使用int min_len=INT32_MAX; //存储最终的最短的长度int temp_len ;//题目中临时用到的长度int e_sum[maxn][maxn];int m;void traceback(int t)//构造回溯函数{    int left,right;//定义一个左右节点。    int temp;//@to_do 在后续的交换操作中会用到；    if(t==n)    {        temp_len=0;//在此处赋予临时变量的值为0，如果此函数内部不赋值temp_len可能会导致全局失效。        for(int i=0;i&lt;m;i++)//从连接块开始遍历        {            for(int j=0;j&lt;n;j++)//接着进行电路板的遍历            {                if(e_sum[originalxu[j]][i]==1)//左边的孩子                {                    left = j;//TODO j和i的顺序不要搞反了；注意这个地方                    break;                }            }            for(int j=n-1;j&gt;=0;j--)            {                if(e_sum[originalxu[j]][i]==1)//右边的孩子                {                    right = j;                    break;                }            }            if(temp_len&lt;right-left)            {                temp_len = right-left;//记录最大长度；            }        }        if(temp_len&lt;min_len) {            min_len = temp_len; //记录最大长度            for(int i=0;i&lt;n;i++) {                finalxu[i] = originalxu[i];//把顺序付给新的变量；            }        }    }    for(int i=t;i&lt;n;i++)    {        temp = originalxu[i];        originalxu[i]=originalxu[t];        originalxu[t]=temp;        traceback(t+1);        temp = originalxu[i];        originalxu[i]=originalxu[t];        originalxu[t]=temp;    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            cin&gt;&gt;e_sum[i][j]; //不妨先把变量传递进来        }    }    for(int t=0;t&lt;n;t++){        originalxu[t] = t;    }    traceback(0);    cout&lt;&lt;min_len&lt;&lt;endl;    for(int r=0;r&lt;n;r++)    {        cout&lt;&lt;finalxu[r]+1&lt;&lt;" ";    }    cout&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(四)    总结<br>在写代码的时候，由于不能很好地给比变量进行命名导致某些地方可能一直出错，此外，要理清各个函数之间的关系，不能混淆了i和j，另外临时变量和全局变量一定要搞清楚，有时候在函数内部赋予局部变量会出现一些莫名其妙的bug。<br>顺便总结一下回溯的模板：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 剪支 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的数</title>
      <link href="2021/04/03/you-qu-de-shu/"/>
      <url>2021/04/03/you-qu-de-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题干描述"><a href="#题干描述" class="headerlink" title="题干描述"></a>题干描述</h2><h3 id="201312-4"><a href="#201312-4" class="headerlink" title="201312-4"></a>201312-4</h3><p>我们把一个数称为有趣的，当且仅当：</p><p>1.它的数字只包含 0,1,2,3，且这四个数字都出现过至少一次。</p><p>2.所有的 0都出现在所有的 1之前，而所有的2都出现在所有的 3 之前。</p><p>3.最高位数字不为0。</p><p>因此，符合我们定义的最小的有趣的数是 2013。</p><p>除此以外 ，4位的有趣的数还有两个：2031 和 2301。</p><p>请计算恰好有n位的有趣的数的个数。</p><p>由于答案可能非常大，只需要输出答案除以10^9+7 的余数。</p><p> <strong>输入格式</strong></p><p>  输入只有一行，包括恰好一个正整数n。</p><p><strong>输出格式</strong></p><p>输出只有一行，包括恰好 n 位的整数中有趣的数的个数除以 10^9+7 的余数。</p><p><strong>数据范围</strong></p><p>4≤n≤1000</p><p><strong>输入样例：</strong></p><p>4 </p><p><strong>输出样例：</strong></p><p>3 </p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>根据题干我们需要满足三个要求：</p><p>①0，1，2，3至少出现一次。 ②0在1之前，2在3之前。  ③0不为首位。</p><p>据此我们可以把问题分为若干类。例如：01出现2次，23出现n-2次；01出现3次，23出现n-3次……01出现n-2次，23出现2次。</p><table><thead><tr><th><strong>01</strong>  <strong>（次数）</strong></th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>…………</strong></th><th><strong>n-2</strong></th></tr></thead><tbody><tr><td>23  (次数）</td><td>n-2</td><td>n-3</td><td>n-4</td><td>……………</td><td>2</td></tr></tbody></table><p>   <u>也即是我们算出每一个组合的方案数相加即为总的方案数。</u></p><p><a href="https://imgtu.com/i/cngvu9"><img src="https://z3.ax1x.com/2021/04/03/cngvu9.png" alt="cngvu9.png"></a></p><p>①对于k位01而言，假设前t位放0的话，后k-t位放1。相应的对于每一个t值，都分别对应一种组合。由于0至少出现一次所以对应又k-1种放法。</p><p>②通里得到23的不同的序列选法为n-k-1</p><p>综合上述，最终，我们可以得到方案数之和公式。</p><p><a href="https://imgtu.com/i/cn29N6"><img src="https://z3.ax1x.com/2021/04/03/cn29N6.png" alt="cn29N6.png"></a></p><p><a href="https://imgtu.com/i/cn2F3D"><img src="https://z3.ax1x.com/2021/04/03/cn2F3D.png" alt="cn2F3D.png"></a></p><p>注：第二种方法</p><p>下面开始探索这样的状态有哪些，以及状态之间的相关性。</p><p>按照题意，</p><p>可以出现的数字类型有0、1、2、3且要求的是n位数字的个数，那么对于一个n位数字，</p><p>可以将其状态定义为：n位中有特定类型数字，且满足0在1前、2在3前的个数。</p><p>具体来说：f(n, 0123)表示前n位中同时出现0、1、2、3且满足0在1前、2在3前的数字个数；</p><p>f(n, 012)表示前n位中同时出现0、1、2且满足0在1前、2在3前的数字个数（当然这里没有3，所有2在3前可以视为妥妥能达到）。</p><p>定义了上述状态后，其实可以比较顺畅地想到状态机dp了。在进行状态转移之前，我们可以剔除掉一些无效状态，即肯定不会出现的状态：f(n, 0) 当n=1时，该状态可以出现，但n&gt;1时，数字不能全是0且n位数大于1，由于本题中满足要求的数字至少4位，所以该状态可以剔除；f(n, 1) f(n, 3)由于1前面必须出现0，3前面必须出现2，所以不可能单独有1和3出现，该状态可剔除；……按照上述类似方法，最终可能出现的状态只能有f(n, 2), f(n, 02), f(n, 01), f(n, 23), f(n, 012), f(n, 023), f(n, 0123)，共6种</p><p><a href="https://imgtu.com/i/cn2AjH"><img src="https://z3.ax1x.com/2021/04/03/cn2AjH.png" alt="cn2AjH.png"></a></p><p><u>注：指向状态0123圈圈的箭头表示，0123状态只能由本身及012和023状态转移过来</u>`</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1010, mod = 1e9 + 7;LL a2, a02, a23, a012, a023, a0123;LL t2, t02, t23, t012, t023, t0123;//默认设为0int n;int main() {    cin &gt;&gt; n;    a2 = 1;    for (int i = 2; i &lt;= n; i++) {        // 备份        t2 = a2, t02 = a02, t23 = a23, t012 = a012, t023 = a023, t0123 = a0123;        a2 = t2 % mod;        // 系数02表示在末尾可以加上0或2两种，下同        a02 = (t2 + 2 * t02) % mod;        a23 = (t2 + t23) % mod;        a012 = (t02 + 2 * t012) % mod;        a023 = (t02 + t23 + 2 * t023) % mod        a0123 = (t012 + t023 + 2 * t0123) % mod;    }    cout &lt;&lt; a0123 &lt;&lt; endl;    return 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/cn2K4f"><img src="https://z3.ax1x.com/2021/04/03/cn2K4f.png" alt="cn2K4f.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCF </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/02/hello-world/"/>
      <url>2021/04/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
