<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/05/28/buflab-shi-yan/"/>
      <url>2021/05/28/buflab-shi-yan/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>实验题目：buflab</th><th></th></tr></thead><tbody><tr><td>实验目的：搞懂缓冲区溢出原理，以及堆栈的过程，函数调用的实现过程。</td><td></td></tr><tr><td>实验环境：虚拟机下乌班图32位</td><td></td></tr><tr><td>实验内容及操作步骤：        首先，我们解压文件：tar xvf buflab-handout.tar.gz  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img">  解压以后在查看一下里面有些什么：通过ll看到里面的文件都是可执行的  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img">   这里可以看到解压以后里面一共就三个文件，结合实验指导书，这三个文件的作用是：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img">  接下来首先先将bufbomb这个程序通过objdump进行反汇编，生成其汇编代码进行查看。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img">  和前一个bomb实验一样，我们可以把bufbomb.s文件拖到windows中用notepad++以汇编语言的格式进行查看。  接下来根据自己的userid来生成一个cookie，因为每次运行bufbomb时要用到。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img">  整个实验是针对getbuf具有的漏洞展开的，getbuf函数类似于gets函数，它是读入一段字符串，字符串以\n或者eof表示结束，并把存储起来。getbuf提供的缓冲区只有32个字符大小，但是getbuf本身又对输入的字符是否超过缓冲区大小进行安全检查，从而带来了缓冲区溢出漏洞。以下就是getbuf函数的代码：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img">  我们分别输入低于32个字符长度和高于32个字符长度。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg" alt="img">  可以看到超出的时候就会造成段错误，多出buf的部分就会导致程序的状态被重写，我们正好就可以利用这个漏洞，来编写我们的漏洞利用代码exploit string。     看一下bufbomb的不同的参数的含义。主要用到的就是-u，确保不同的userid用不同的cookie，然后就是-n是为了level4，栈基址随机化模式的时候使用的。-s是上传到服务器进行打分，这个部分是没有的。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img">  然后我们可以把我们的exploit写到一个txt中，然后给出了几种将我们的txt执行的格式：     <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img">  Cat主要是多次提交我们的txt，主要是在level4中会用到，因为level4要求你连续输入5次你的string。然后是一些比较重要的提示事项：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img">  一个是getbuf遇到换行就会认为输入停止，而换行\n的对应的ASCII值是0x0a，所以不可以输入的字符串中含有0x0a另一个就是说，格式转换要注意每次输入的都是两个数字，比如你要输入0，就要输入00。还有要注意小端格式的输入。  首先，我们进入关卡：  Level 0：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img">  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="img">  通过观察函数，我们发现test函数中对getbuf函数进行了调用。我们要做的就是在调用getbuf函数的时候，我们输入exploit 后，返回的是我们想要调用的smoke函数，而不是test函数的返回值。  这里的实现，我们只需要输入超出缓冲区大小的字符串覆盖getbuf的返回地址的那块地方，并将多余的返回地址用smoke函数的入口地址代替。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg" alt="img">  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png" alt="文本框: 我们先用44个00覆盖字节码，接着我们用再smoke函数的调用入口地址，也就是相当于调用了smoke函数。 按照这样的思路我们可以找到smoke的函数地址   又因为0x0a对应的ASCII值为“\n”,通过阅读前面的pdf文件，我们发现当字符串读入\n是相当于读入了一个换行符，因此，我们可以把下一个地址，0x8048e0b作为地址，因为我们前面输入的44个00相当于对push ebp造成了不可恢复的毁坏，因此紧接着对mov的使用，相当于可以直接调用，至此，我们可以创建如下txt文件。 ">Getbuf的esp中开辟了0x28的字节，而push  ebp占用了四个字节，故getbuf的栈空间总计44个字节。                        返回地址                  保存的ebp                  保存的ebx                  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png" alt="img"> ………                  返回地址                  保存的ebp,(text)                       <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image031.jpg" alt="img">  我们输入如下指令：./hex2raw &lt;level0.txt |./bufbomb -u syq  可以看出验证成功。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg" alt="img">     <strong>LEVEL****１</strong>  Level1是和level0一样调用完getbuf以后我们不返回getbuf的调用者test而是去执行fizz函数，区别就是这个fizz函数要求我们传入参数，而且传入的参数必须是我们的cookie。     我们首先找到ｆｉｚｚ的函数入口地址：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg" alt="img">  此地址为：０ｘ０８０４８ｄａｆ  根据接下来的两行可以知道：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg" alt="img">  传入的参数，存在了ｅｂｐ＋８的位置。这样执行ｆｉｚｚ时传入的就是我们ｃｏｏｋｉｅ作为的参数了。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png" alt="文本框: 按照同样的方法，我们创建ｌｅｖｅｌ１．ｔｘｔ文件   执行一下看看结果：   ">如图所示：　　　　　　　　　　　　             返回地址                  保存的ebp                  保存的ebx                   ………                  　ｅｓｐ　＋　８    　ｃｏｏｋｉｅ                  ００　００　００　００原ｔｅｓｔ的ｅｓｐ的栈顶。                  返回地址                  保存的ebp,(text)　ｆｉｚｚ                  ０００００００００００００００００                       <strong>LEVEL 2</strong>  任务：这一关是要执行栈中你的指定的特殊指令，设置一个全局变量为我  bufbomb在getbuf()函数返回会执行bang()函数。但是在执行bang()函数之前我们需要设计全局变量global_value为我们自己userid的cookie。  同样地：先得到bang函数的入口地址为：0x08048d52、  因为全局变量要去内存地址中修改了，但是又不能调用个一个可以修改全局变量的函数，这里就只能利用我们的exploit代码了。  接着，我们观察bang的反汇编代码。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image042.jpg" alt="img">  这里我们看到，mov 应该就是把我们的0x804d10c中的全局变量取出来放入eax寄存器中，然后cmp一句可以看出来我们的全局变量与cookie进行比较。  那么我们就要来编写我们的漏洞利用代码了，首先把我们的cookie写到全局变量的地址中，然后在把bang的入口地址入栈，通过ret指令来执行bang函数，这里的push bang的入口地址。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image044.jpg" alt="img">  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image046.jpg" alt="img">  查看code.d文件。  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image048.jpg" alt="img">  我们就要利用gdb调试找到我们的exploit的地址了，用我们的地址来覆盖返回地址，这样就像我们前面分析的就可以来执行我们的exploit代码了。首先在getbuf函数里面设置断点：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image050.jpg" alt="img">  观察到eax = 0x55683248  于是我们就可以构造相应的level2.txt函数  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image052.jpg" alt="img">  执行完后，结果如下：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image054.jpg" alt="img">     <strong>LEVEL 3</strong>  前面的几个实验都是不管是去执行别的函数比如bang还是去执行我们自己的exploit的函数，最后都没有返回就退出了，我们通过我们的漏洞利用代码可以修改内存（比如把全局变量修改为我们的cookie）修改寄存器中的值，比如当前的level3，我们都把原来的恢复现场需要用的返回地址和原test的ebp给破坏了，这一关中，我们将修复这些被我们破坏的栈状态信息，让最后还是回到test中，     我的基本思路：就是函数调用栈，函数调用结束以后，栈被释放，而返回结果会放在eax寄存器中，这样test这个调用者不需知道调用的getbuf是怎么执行的，只需要到eax寄存器中去取返回值就好了，那么我们就在getbuf执行完以后，再把eax寄存器中的值动手脚修改为我们的cookie就ok了。     同样的，我们先看getbuf函指令执行位置为：0x8049262  调用getbuf()会在栈中保存一个  old %ebp值, 这个值是test函数的%ebp值,这个值需要正确返回.  用GDB调试得到这个值old %ebp为0x55683480.  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image056.jpg" alt="img">  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image058.jpg" alt="img">  EBP：0x556832a0  然后eip的地址，就是返回地址，也就是test中在call getbuf函数的下一条指令的地址，可以看到call的下一条指令的地址是0x8048e50  因为我们要执行破坏一定会先破坏原栈状态，所以我们只需要在写入的漏洞代码中恢复即可。我在这里用的是覆盖掉原ebp的值不管别的  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg" alt="img">  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg" alt="img">  至此，我们可以编出level3.txt文件  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg" alt="img">  执行一下：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image066.jpg" alt="img">  level4  <strong>任务</strong>  <strong>（<strong><strong>1</strong></strong>）确定<strong><strong>buf</strong></strong>的起始地址范围**</strong> **  <strong>（<strong><strong>2</strong></strong>）获取<strong><strong>tesdn</strong></strong>函数的正确**</strong>%ebp<strong><strong>指针内容。</strong></strong> **  <strong>（<strong><strong>3</strong></strong>）确定序列中填充的跳转地址</strong>  前面4关在调用getbuf函数时其栈的位置是不变的.这一关调用的是getbufn函数,其目的是为了随机化栈基址。首先来看一下getbufn函数的汇编代码：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg" alt="img">  可以看出buf的首地址为  -0x208为十进制520个字节的大小。     但是栈顶的esp是不变的  先通过调试来看一下getbuf里面保存的ebp的值的随机范围为多少。     我们在0x8049247处设置断点，注意与前面不同的是设置为-n模式，然后每次输入一次string来看一下ebp的值，然后continue，再次输入，一共输入5次。run -nu syq                ebp            减去0x208为buf的首地址                  0x55683270            0x55683068                   0x556832c0             0x556830b8                   0x55683280             0x55683078                   0x55683290             0x55683088                   0x556831f0             0x556830e8                                                  接下来再来看一下testn的反汇编代码：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg" alt="img">     这里我们可以看到，call  getbufn的下一条指令的地址为0x8048ce2     还可以看到，mov %esp,%ebp 此时esp和ebp相等     push %ebx 此时ebp=esp+0x4     sub  $0x24,%esp 这个时候执行完后，ebp=esp+0x28，这就是esp和ebp每次的变化关系，通过esp来恢复我们的每次的ebp  因此，我们可以写出如下漏洞代码：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg" alt="img">        <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image074.jpg" alt="img">  接下来构造我们的level4.txt exploit sting  Buf一共520个字节空间加上返回地址和ebp一共是528个。用buf的首地址覆盖返回地址。们随便算一个即可，在这里我选的是：0x556830e8  前505个字节都是90，即机器指令空操作nop。  部分截图如下：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image076.jpg" alt="img">  执行一下：  <img src="file:///C:/Users/PC/AppData/Local/Temp/msohtmlclip1/01/clip_image078.jpg" alt="img">     与前面几关不同的是我们使用了如下的指令.  cat level4.txt | ./hex2raw  -n | ./bufbomb -n -u syq  以保证input  string 被复制五次每次以\n结尾以结束每次的gets()函数调用。     <strong>实验感悟：</strong>    通过本次实验，对栈帧结构有了进一步的认识，old ebp和esp是整个实验的关键点。除此之外，gdb的调试，设置断点，进一步熟练。同时，有认识到了一些新指令。  实验过程总体上还是比较顺利的，可能因为第一次实验的缘故。</td><td></td></tr><tr><td>实  验成绩</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最小电路板长度排列问题</title>
      <link href="2021/04/20/zui-xiao-dian-lu-ban-chang-du-pai-lie-wen-ti/"/>
      <url>2021/04/20/zui-xiao-dian-lu-ban-chang-du-pai-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>本次实验，我选择课本P156页5-2作为实验报告。</p><p>(1) 首先是问题描述：</p><p>最小长度电路板排列问题是大规模电子系统设计中提出的实际问题。该问题的提法是，将n块电路板以最佳排列方案插入带有n个插槽的机箱中。n块电路板的不同的排列方式对应于不同的电路板插入方案。</p><p>设B={1，2，…，n }是n块电路板的集合。集合L={ N1，N2，…，Nm }是n块电路 板的m个连接块。其中每个连接块Ni是B的一个子集，且Ni中的电路板用同一根导线连 接在一起。</p><p>例如，设n=8，m=5。给定n块电路板及其m个连接块如下：</p><p>B={1，2，3，4，5，6，7，8}；L={ N1，N2，N3，N4，N5}；</p><p>N1={4，5，6}； N2={2，3}； N3 ={1，3}； N4={3，6}； N5 ={7，8}。</p><p>这8块电路板的一个可能的排列如图所示。</p><p><img src="https://img-blog.csdnimg.cn/20210420173938424.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210420173958255.png" alt="在这里插入图片描述"></p><p>则该电路板排列的密度分别是2，3。</p><p> 左上图中，跨越插槽2和3,4和5，以及插槽5和6的连线数均为2。插槽6和7之间无跨越连线。其余插槽之间只有1条跨越连线。在设计机箱时，插槽一侧的布线间隙由电路板的排列的密度确定。因此，电路板排列问题要求对于给定的电路板连接条件(连接块)，确定电路板的最佳排列，使其具有最小密度。</p><p>(2) 问题分析</p><p>电路板排列问题是NP难问题，因此不大可能找到解此问题的多项式时间算法。考虑采用回溯法系统的搜索问题解空间的排列树，找出电路板的最佳排列。排列树问题。对所有的电路板进行全排列，每次找到连接块的最左和最右电路板，相减得到连接块的长度，在全排列的过程中找到最小长度。</p><p>(3) 代码描述</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//最小电路板排列问题#include&lt;iostream&gt;using namespace std;const int maxn = 10000;int originalxu[maxn];//保留初始排序int finalxu[maxn];//保留处理后的排序int n;//讲变量n分配到全局，方便后续的使用int min_len=INT32_MAX; //存储最终的最短的长度int temp_len ;//题目中临时用到的长度int e_sum[maxn][maxn];int m;void traceback(int t)//构造回溯函数{    int left,right;//定义一个左右节点。    int temp;//@to_do 在后续的交换操作中会用到；    if(t==n)    {        temp_len=0;//在此处赋予临时变量的值为0，如果此函数内部不赋值temp_len可能会导致全局失效。        for(int i=0;i&lt;m;i++)//从连接块开始遍历        {            for(int j=0;j&lt;n;j++)//接着进行电路板的遍历            {                if(e_sum[originalxu[j]][i]==1)//左边的孩子                {                    left = j;//TODO j和i的顺序不要搞反了；注意这个地方                    break;                }            }            for(int j=n-1;j&gt;=0;j--)            {                if(e_sum[originalxu[j]][i]==1)//右边的孩子                {                    right = j;                    break;                }            }            if(temp_len&lt;right-left)            {                temp_len = right-left;//记录最大长度；            }        }        if(temp_len&lt;min_len) {            min_len = temp_len; //记录最大长度中的最小值            for(int i=0;i&lt;n;i++) {                finalxu[i] = originalxu[i];//把顺序赋给新的变量；            }        }    }    for(int i=t;i&lt;n;i++)    {        temp = originalxu[i];        originalxu[i]=originalxu[t];        originalxu[t]=temp;        traceback(t+1);        temp = originalxu[i];        originalxu[i]=originalxu[t];        originalxu[t]=temp;    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;m;j++)        {            cin&gt;&gt;e_sum[i][j]; //不妨先把变量传递进来        }    }    for(int t=0;t&lt;n;t++){        originalxu[t] = t;    }    traceback(0);    cout&lt;&lt;min_len&lt;&lt;endl;    for(int r=0;r&lt;n;r++)    {        cout&lt;&lt;finalxu[r]+1&lt;&lt;" ";    }    cout&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(四)    总结<br>在写代码的时候，由于不能很好地给比变量进行命名导致某些地方可能一直出错，此外，要理清各个函数之间的关系，不能混淆了i和j，另外临时变量和全局变量一定要搞清楚，有时候在函数内部赋予局部变量会出现一些莫名其妙的bug。<br>顺便总结一下回溯的模板：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 剪支 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的数</title>
      <link href="2021/04/03/you-qu-de-shu/"/>
      <url>2021/04/03/you-qu-de-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题干描述"><a href="#题干描述" class="headerlink" title="题干描述"></a>题干描述</h2><h3 id="201312-4"><a href="#201312-4" class="headerlink" title="201312-4"></a>201312-4</h3><p>我们把一个数称为有趣的，当且仅当：</p><p>1.它的数字只包含 0,1,2,3，且这四个数字都出现过至少一次。</p><p>2.所有的 0都出现在所有的 1之前，而所有的2都出现在所有的 3 之前。</p><p>3.最高位数字不为0。</p><p>因此，符合我们定义的最小的有趣的数是 2013。</p><p>除此以外 ，4位的有趣的数还有两个：2031 和 2301。</p><p>请计算恰好有n位的有趣的数的个数。</p><p>由于答案可能非常大，只需要输出答案除以10^9+7 的余数。</p><p> <strong>输入格式</strong></p><p>  输入只有一行，包括恰好一个正整数n。</p><p><strong>输出格式</strong></p><p>输出只有一行，包括恰好 n 位的整数中有趣的数的个数除以 10^9+7 的余数。</p><p><strong>数据范围</strong></p><p>4≤n≤1000</p><p><strong>输入样例：</strong></p><p>4 </p><p><strong>输出样例：</strong></p><p>3 </p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>根据题干我们需要满足三个要求：</p><p>①0，1，2，3至少出现一次。 ②0在1之前，2在3之前。  ③0不为首位。</p><p>据此我们可以把问题分为若干类。例如：01出现2次，23出现n-2次；01出现3次，23出现n-3次……01出现n-2次，23出现2次。</p><table><thead><tr><th><strong>01</strong>  <strong>（次数）</strong></th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>…………</strong></th><th><strong>n-2</strong></th></tr></thead><tbody><tr><td>23  (次数）</td><td>n-2</td><td>n-3</td><td>n-4</td><td>……………</td><td>2</td></tr></tbody></table><p>   <u>也即是我们算出每一个组合的方案数相加即为总的方案数。</u></p><p><a href="https://imgtu.com/i/cngvu9"><img src="https://z3.ax1x.com/2021/04/03/cngvu9.png" alt="cngvu9.png"></a></p><p>①对于k位01而言，假设前t位放0的话，后k-t位放1。相应的对于每一个t值，都分别对应一种组合。由于0至少出现一次所以对应又k-1种放法。</p><p>②通里得到23的不同的序列选法为n-k-1</p><p>综合上述，最终，我们可以得到方案数之和公式。</p><p><a href="https://imgtu.com/i/cn29N6"><img src="https://z3.ax1x.com/2021/04/03/cn29N6.png" alt="cn29N6.png"></a></p><p><a href="https://imgtu.com/i/cn2F3D"><img src="https://z3.ax1x.com/2021/04/03/cn2F3D.png" alt="cn2F3D.png"></a></p><p>注：第二种方法</p><p>下面开始探索这样的状态有哪些，以及状态之间的相关性。</p><p>按照题意，</p><p>可以出现的数字类型有0、1、2、3且要求的是n位数字的个数，那么对于一个n位数字，</p><p>可以将其状态定义为：n位中有特定类型数字，且满足0在1前、2在3前的个数。</p><p>具体来说：f(n, 0123)表示前n位中同时出现0、1、2、3且满足0在1前、2在3前的数字个数；</p><p>f(n, 012)表示前n位中同时出现0、1、2且满足0在1前、2在3前的数字个数（当然这里没有3，所有2在3前可以视为妥妥能达到）。</p><p>定义了上述状态后，其实可以比较顺畅地想到状态机dp了。在进行状态转移之前，我们可以剔除掉一些无效状态，即肯定不会出现的状态：f(n, 0) 当n=1时，该状态可以出现，但n&gt;1时，数字不能全是0且n位数大于1，由于本题中满足要求的数字至少4位，所以该状态可以剔除；f(n, 1) f(n, 3)由于1前面必须出现0，3前面必须出现2，所以不可能单独有1和3出现，该状态可剔除；……按照上述类似方法，最终可能出现的状态只能有f(n, 2), f(n, 02), f(n, 01), f(n, 23), f(n, 012), f(n, 023), f(n, 0123)，共6种</p><p><a href="https://imgtu.com/i/cn2AjH"><img src="https://z3.ax1x.com/2021/04/03/cn2AjH.png" alt="cn2AjH.png"></a></p><p><u>注：指向状态0123圈圈的箭头表示，0123状态只能由本身及012和023状态转移过来</u>`</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1010, mod = 1e9 + 7;LL a2, a02, a23, a012, a023, a0123;LL t2, t02, t23, t012, t023, t0123;//默认设为0int n;int main() {    cin &gt;&gt; n;    a2 = 1;    for (int i = 2; i &lt;= n; i++) {        // 备份        t2 = a2, t02 = a02, t23 = a23, t012 = a012, t023 = a023, t0123 = a0123;        a2 = t2 % mod;        // 系数02表示在末尾可以加上0或2两种，下同        a02 = (t2 + 2 * t02) % mod;        a23 = (t2 + t23) % mod;        a012 = (t02 + 2 * t012) % mod;        a023 = (t02 + t23 + 2 * t023) % mod        a0123 = (t012 + t023 + 2 * t0123) % mod;    }    cout &lt;&lt; a0123 &lt;&lt; endl;    return 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/cn2K4f"><img src="https://z3.ax1x.com/2021/04/03/cn2K4f.png" alt="cn2K4f.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCF </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/02/hello-world/"/>
      <url>2021/04/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
